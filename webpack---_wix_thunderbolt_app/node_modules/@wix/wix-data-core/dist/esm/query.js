import {
    isString,
    clone
} from '@wix/wix-data-utils';
import {
    apiValidator,
    messages,
    validationError
} from '@wix/wix-data-errors';
import {
    filterMixin,
    optimiseQuery
} from '@wix/platformized-filter-builder';
import sortMixin from './sort/sortMixin';
import {
    isCursorDefined
} from './paging/cursors';
import {
    PagingMetadata
} from './paging/pagingmetadata';
import {
    calcSkipNumber
} from './utils/skip-calculator';
import QueryValidator from './QueryValidator';
export class WixDataQuery extends filterMixin(sortMixin()) {
    constructor(obj) {
        super(obj);
        this.provider = obj.provider;
        this.collectionName = obj.collectionName;
        this.limitNumber = obj.limitNumber;
        this.invalidArguments = obj.invalidArguments;
        this.orderBy = obj.orderBy;
        this.skipNumber = obj.skipNumber;
        this.included = obj.included;
        this.projectedFields = obj.projectedFields;
        this.cursor = obj.cursor;
    }
    get constructorName() {
        return 'WixDataQuery';
    }
    count(options) {
        return rejectIfInvalid(this.invalidArguments, this.collectionName)
            .then(() => apiValidator().options(options).validateAndReject())
            .then(() => this.provider.count(this.collectionName, this.getOptimizedFilter(), options))
            .then((result) => result.totalCount);
    }
    distinct(fieldName, options) {
        const self = this;
        const omitTotalCount = (options || {}).omitTotalCount;
        const skipNumber = this.cursor ? undefined : this.skipNumber;
        const fieldNameUpdated = this.cursor ? '' : fieldName;
        return rejectIfInvalid(this.invalidArguments, this.collectionName)
            .then(() => apiValidator().options(options).validateAndReject())
            .then(() => apiValidator().fieldName(fieldNameUpdated).validateAndReject())
            .then(() => this.provider.distinct(this.collectionName, this.getOptimizedFilter(), this.orderBy, fieldNameUpdated, skipNumber, this.limitNumber, options, this.cursor, undefined, omitTotalCount))
            .then((result) => {
                const pagingMetadata = result.pagingMetadata || new PagingMetadata();
                const {
                    cursors,
                    hasNext = false
                } = pagingMetadata;
                const isCursored = isCursorDefined(cursors ? .next) || isCursorDefined(cursors ? .prev);
                const optionsUpdated = isCursored ?
                    { ...options,
                        omitTotalCount: true
                    } :
                    options;
                return new WixDataQueryResult({
                    createdByCursor: this.cursor,
                    items: result.items,
                    length: result.items.length,
                    query: self,
                    totalCount: result.totalCount,
                    cursors,
                    partialIncludes: false,
                    pagingFunction() {
                        return this.distinct(fieldNameUpdated, optionsUpdated);
                    },
                    hasNext,
                });
            });
    }
    _transformOrderingForAggregates(orderBy = [], fieldName) {
        if (orderBy.length > 0) {
            return orderBy
                .filter((order) => order.hasOwnProperty(fieldName))
                .map((order) => {
                    return {
                        _id: order[fieldName]
                    };
                });
        } else {
            return null;
        }
    }
    _distinctValuesPipeline(fieldName) {
        return [
            this.filterTree && Object.keys(this.filterTree).length > 0 ?
            {
                $match: this.filterTree
            } :
            null,
            {
                $distinct: `$${fieldName}`
            },
        ].filter(this._stageFilter);
    }
    _stageFilter(stage) {
        return stage !== null;
    }
    fields(...fields) {
        const newProjectedFields = clone(this.projectedFields);
        for (let i = 0; i < fields.length; i++) {
            newProjectedFields.push(fields[i]);
        }
        return new WixDataQuery({
            provider: this.provider,
            collectionName: this.collectionName,
            filterTree: this.filterTree,
            orderBy: this.orderBy,
            skipNumber: this.skipNumber,
            limitNumber: this.limitNumber,
            invalidArguments: this.invalidArguments,
            included: this.included,
            cursor: this.cursor,
            projectedFields: newProjectedFields,
        });
    }
    find(options) {
        const self = this;
        const omitTotalCount = (options || {}).omitTotalCount;
        return rejectIfInvalid(this.invalidArguments, this.collectionName)
            .then(() => apiValidator().options(options).validateAndReject())
            .then(() => {
                const skipNumber = this.cursor ? undefined : this.skipNumber;
                return this.provider.find(this.collectionName, this.getOptimizedFilter(), this.orderBy, skipNumber, this.limitNumber, options, this.included, omitTotalCount, this.cursor, this.projectedFields);
            })
            .then((result) => {
                const cursors = result.pagingMetadata.cursors;
                const isCursored = isCursorDefined(cursors ? .next) || isCursorDefined(cursors ? .prev);
                const optionsUpdated = isCursored ?
                    { ...options,
                        omitTotalCount: true
                    } :
                    options;
                return new WixDataQueryResult({
                    createdByCursor: this.cursor,
                    totalCount: result.totalCount,
                    query: self,
                    items: result.items,
                    cursors,
                    partialIncludes: result.partialIncludes,
                    hasNext: result.pagingMetadata.hasNext,
                    pagingFunction() {
                        return this.find(optionsUpdated);
                    },
                });
            });
    }
    limit(limitNumber) {
        const [newInvalidArguments] = this._queryValidator('.limit')
            .arityIsOne(arguments)
            .isPositiveNumber(limitNumber)
            .isInteger(limitNumber)
            .validateAndAggregate();
        return new WixDataQuery({
            provider: this.provider,
            collectionName: this.collectionName,
            filterTree: this.filterTree,
            orderBy: this.orderBy,
            skipNumber: this.skipNumber,
            limitNumber,
            included: this.included,
            cursor: this.cursor,
            invalidArguments: newInvalidArguments,
            projectedFields: this.projectedFields,
        });
    }
    skip(skipNumber) {
        const [newInvalidArguments] = this._queryValidator('.skip')
            .arityIsOne(arguments)
            .isNonNegativeNumber(skipNumber)
            .isInteger(skipNumber)
            .validateAndAggregate();
        return new WixDataQuery({
            provider: this.provider,
            collectionName: this.collectionName,
            filterTree: this.filterTree,
            orderBy: this.orderBy,
            skipNumber,
            limitNumber: this.limitNumber,
            included: this.included,
            cursor: this.cursor,
            invalidArguments: newInvalidArguments,
            projectedFields: this.projectedFields,
        });
    }
    include(...propertyName) {
        const newIncludedFields = clone(this.included);
        for (let i = 0; i < propertyName.length; i++) {
            newIncludedFields.push(propertyName[i]);
        }
        return new WixDataQuery({
            provider: this.provider,
            collectionName: this.collectionName,
            filterTree: this.filterTree,
            orderBy: this.orderBy,
            skipNumber: this.skipNumber,
            limitNumber: this.limitNumber,
            invalidArguments: this.invalidArguments,
            included: newIncludedFields,
            cursor: this.cursor,
            projectedFields: this.projectedFields,
        });
    }
    setFilterModel(filterModel) {
        const newQuery = super.setFilterModel(filterModel);
        return this._setQuerySpecificInvalidArguments(newQuery);
    }
    getOptimizedFilter() {
        try {
            return optimiseQuery(this.filterTree);
        } catch (e) {
            // there's no filter schema validation in `setFilterModel`
            // so filter should be passed as-is and detailed validation errors received from backend
            return this.filterTree;
        }
    }
    setSortModel(sortModel) {
        const newQuery = super.setSortModel(sortModel);
        return this._setQuerySpecificInvalidArguments(newQuery);
    }
    _setQuerySpecificInvalidArguments(newQuery) {
        const validateIfDefined = (value, validator) => value !== undefined ? validator.validateAndAggregate()[0] : [];
        const limitValidator = this._queryValidator('.limit', [])
            .isPositiveNumber(this.limitNumber)
            .isInteger(this.limitNumber);
        const skipValidator = this._queryValidator('.skip', [])
            .isNonNegativeNumber(this.skipNumber)
            .isInteger(this.skipNumber);
        const invalidArguments = [
            ...validateIfDefined(this.limitNumber, limitValidator),
            ...validateIfDefined(this.skipNumber, skipValidator),
        ];
        return Object.assign(newQuery, {
            invalidArguments
        });
    }
    _queryValidator(operatorName, invalidArguments = this.invalidArguments) {
        return new QueryValidator(operatorName, invalidArguments);
    }
}

function rejectIfInvalid(invalidArguments, collectionName) {
    const collectionNameInvalid = isString(collectionName) ?
        [] :
        [messages.collectionNameMustBeAString()];
    const allInvalids = collectionNameInvalid.concat(invalidArguments);
    if (allInvalids.length > 0) {
        return Promise.reject(validationError(messages.queryValidations.queryInvalid(collectionName, allInvalids)));
    } else {
        return Promise.resolve();
    }
}
export function queryFactory(provider, collectionName) {
    return new WixDataQuery({
        provider,
        collectionName,
        filterTree: {},
        orderBy: undefined,
        skipNumber: 0,
        invalidArguments: [],
        included: [],
        projectedFields: [],
    });
}
export class WixDataQueryResult {
    constructor(obj) {
        this._executeQuery = (query) => this._pagingFunction.bind(query)();
        this._withCalculatedSkip = (query, isNext) => {
            query.skipNumber = calcSkipNumber(this.query, this.length, isNext);
            return Promise.resolve(query);
        };
        if (!obj) {
            return;
        }
        this._items = obj.items;
        this._totalCount = obj.totalCount;
        this._cursors = obj.cursors;
        this._createdByCursor = obj.createdByCursor;
        this._query = obj.query;
        this._partialIncludes = obj.partialIncludes;
        this._pagingFunction = obj.pagingFunction;
        this._hasNext = obj.hasNext;
        // todo: to not forget
        // these properties are used by the client - they shouldn't be defined here....BUT since they are, we'll keep them for now, and move them later on to the client.
        this.nextSkipNumber = calcSkipNumber(this.query, this.length, true);
        this.prevSkipNumber = calcSkipNumber(this.query, this.length, false);
    }
    get items() {
        return this._items;
    }
    get length() {
        return this.items.length;
    }
    get totalCount() {
        return this._totalCount;
    }
    get query() {
        return this._query;
    }
    get pageSize() {
        return this._query.limitNumber;
    }
    get totalPages() {
        if (this.totalCount && this.pageSize) {
            return Math.ceil(this.totalCount / this.pageSize);
        }
        if (this.totalCount === 0) {
            return 0;
        }
        const skip = this.query.skipNumber || 0;
        if (this.totalCount && this.length + skip <= this.totalCount) {
            return Math.ceil(this.totalCount / this.length);
        }
        return undefined;
    }
    get currentPage() {
        if (this.length === 0) {
            return undefined;
        }
        const skip = this.query.skipNumber || 0;
        if (this.totalCount <= 0 ||
            skip >= this.totalCount ||
            this.pageSize === undefined) {
            if (this.hasNext()) {
                return Math.floor(skip / this.length);
            }
            return undefined;
        }
        return Math.floor(skip / this.pageSize);
    }
    get partialIncludes() {
        return this._partialIncludes;
    }
    next() {
        if (!this.hasNext()) {
            return this._rejectNoNextPage();
        }
        if (isCursorDefined(this.nextCursor)) {
            return this._getNewCursorQuery(this.nextCursor, true)
                .then((query) => this._executeQuery(query))
                .then((result) => result._withTotalCount(this._totalCount));
        } else {
            return this._getNewQuery(true).then((query) => this._executeQuery(query));
        }
    }
    prev() {
        if (!this.hasPrev()) {
            return this._rejectNoPrevPage();
        }
        if (isCursorDefined(this.prevCursor)) {
            return this._getNewCursorQuery(this.prevCursor, false)
                .then((query) => this._executeQuery(query))
                .then((result) => result._withTotalCount(this._totalCount));
        }
        return this._getNewQuery(false).then((query) => this._executeQuery(query));
    }
    get nextCursor() {
        return this._cursors && this._cursors.next;
    }
    get prevCursor() {
        return this._cursors && this._cursors.prev;
    }
    hasNext() {
        return this._hasNext;
    }
    hasPrev() {
        if (isCursorDefined(this._createdByCursor) || this._cursors) {
            return isCursorDefined(this.prevCursor);
        }
        const usedSkipNumber = this.query.skipNumber || 0;
        if (usedSkipNumber === 0 || this.totalCount <= 0) {
            return false;
        }
        const prevSkipNumber = calcSkipNumber(this.query, this.length, false);
        return prevSkipNumber >= 0;
    }
    toJSON() {
        return {
            currentPage: this.currentPage,
            items: this.items,
            length: this.length,
            pageSize: this.pageSize,
            partialIncludes: this.partialIncludes,
            query: this.query,
            totalCount: this.totalCount,
            totalPages: this.totalPages,
        };
    }
    _getNewQuery(isNext) {
        return this._withCalculatedSkip(new WixDataQuery({
            provider: this.query.provider,
            collectionName: this.query.collectionName,
            filterTree: this.query.filterTree,
            orderBy: this.query.orderBy,
            limitNumber: this.query.limitNumber,
            included: this.query.included,
            invalidArguments: [],
            projectedFields: this.query.projectedFields,
        }), isNext);
    }
    _getNewCursorQuery(cursor, isNext) {
        const query = new WixDataQuery({
            provider: this.query.provider,
            collectionName: this.query.collectionName,
            filterTree: {},
            limitNumber: this.query.limitNumber,
            invalidArguments: [],
            cursor,
            included: this.query.included,
            projectedFields: this.query.projectedFields,
        });
        return this._withCalculatedSkip(query, isNext);
    }
    _withTotalCount(oldTotalCount) {
        this._totalCount = oldTotalCount;
        return this;
    }
    _rejectNoPrevPage() {
        return Promise.reject(validationError(messages.queryValidations.noPrevPage(this.query.collectionName)));
    }
    _rejectNoNextPage() {
        return Promise.reject(validationError(messages.queryValidations.noNextPage(this.query.collectionName)));
    }
}
export function queryResultFactory(result, provider, collectionName, limit, options, cursor) {
    const {
        items,
        totalCount,
        partialIncludes,
        pagingMetadata
    } = result;
    const {
        cursors,
        hasNext = false
    } = pagingMetadata || new PagingMetadata();
    const query = queryFactory(provider, collectionName).limit(limit);
    // Always omit total count if follow-up requests are with cursors
    const isCursored = isCursorDefined(cursors ? .next) || isCursorDefined(cursors ? .prev);
    const updatedOptions = isCursored ?
        { ...options,
            omitTotalCount: true
        } :
        options;
    return new WixDataQueryResult({
        createdByCursor: cursor,
        items,
        totalCount,
        partialIncludes,
        cursors,
        query,
        pagingFunction() {
            return this.find(updatedOptions);
        },
        hasNext,
    });
}
//# sourceMappingURL=query.js.map