import {
    handleJsonResponse,
    parseBulkError,
    parseBulkDataItemsError,
    handleJsonErrorResponse,
} from './platformized-data-response';
import {
    apiValidator,
    codes,
    validationError,
    messages,
    wixDataError,
} from '@wix/wix-data-errors';
import {
    serializeDates,
    isArray,
    isObject,
    isString,
    isDate,
    isNumber,
    toPlatformizedAggregate,
    base64url,
} from '@wix/wix-data-utils';
import {
    noopTraceWith
} from './trace-with';
import toDataItemsAggregate from './dataItemsAggregate';
const isProvider = (candidate) => typeof candidate === 'object' &&
    candidate !== null &&
    'get' in candidate &&
    typeof candidate.get === 'function';
export class PlatformizedWixDataProvider {
    constructor({
        cloudDataUrl = '/_api/cloud-data',
        gridAppId,
        segment,
        httpClient,
        authHeader,
        traceWith = noopTraceWith,
        allowGetRequests = false,
        shouldUseDataItemService = Promise.resolve(false),
    }) {
        this.cloudDataUrl = cloudDataUrl;
        this.gridAppId = gridAppId;
        this.segment = segment;
        this.httpClientProvider =
            typeof httpClient === 'function' ? httpClient : () => httpClient;
        this.traceWith = traceWith;
        this.authHeader = authHeader;
        this.allowGetRequests = allowGetRequests;
        this.shouldUseDataItemService = shouldUseDataItemService;
    }
    _unwarpDataItems(items) {
        return items.map((item) => item.data);
    }
    _unwrapDataItem(response) {
        if (response &&
            response.hasOwnProperty('dataItem') &&
            response.dataItem.hasOwnProperty('data')) {
            return {
                item: response.dataItem.data,
            };
        } else {
            return response;
        }
    }
    insert(collectionName, item, options) {
        return this._traceWith('platformized-provider-insert', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .item(item, collectionName, false)
            .options(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (useDataItemService) {
                    return this._call('/v2/items', {
                        dataCollectionId: collectionName,
                        dataItem: {
                            id: item._id,
                            dataCollectionId: collectionName,
                            data: item,
                        },
                        includeReferencedItems: options && options.includeReferences,
                        options: this._optionsWithPluginsItemService(options),
                    }, false, useDataItemService).then(this._unwrapDataItem);
                } else {
                    return this._call('/v1/wix-data/collections/insert', {
                        collectionName,
                        item,
                        options: this._optionsWithPlugins(options),
                    });
                }
            }));
    }
    update(collectionName, item, options) {
        return this._traceWith('platformized-provider-update', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .item(item, collectionName, false)
            .options(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (useDataItemService) {
                    return this._call('/v2/items/update', {
                        dataCollectionId: collectionName,
                        dataItem: {
                            id: item._id,
                            dataCollectionId: collectionName,
                            data: item,
                        },
                        includeReferencedItems: options && options.includeReferences,
                        options: this._optionsWithPluginsItemService(options),
                    }, false, useDataItemService).then(this._unwrapDataItem);
                } else {
                    return this._call('/v1/wix-data/collections/update', {
                        collectionName,
                        item,
                        options: this._optionsWithPlugins(options),
                    });
                }
            }));
    }
    save(collectionName, item, options) {
        return this._traceWith('platformized-provider-save', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .item(item, collectionName, false)
            .options(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (useDataItemService) {
                    return this._call('/v2/items/save', {
                        dataCollectionId: collectionName,
                        dataItem: {
                            id: item._id,
                            dataCollectionId: collectionName,
                            data: item,
                        },
                        includeReferencedItems: options && options.includeReferences,
                        options: this._optionsWithPluginsItemService(options),
                    }, false, useDataItemService).then(this._unwrapDataItem);
                } else {
                    return this._call('/v1/wix-data/collections/save', {
                        collectionName,
                        item,
                        options: this._optionsWithPlugins(options),
                    });
                }
            }));
    }
    truncate(collectionName, options) {
        return this._traceWith('platformized-provider-truncate', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .truncateOptions(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (useDataItemService) {
                    return this._call('/v2/items/truncate', {
                        dataCollectionId: collectionName,
                        options: this._optionsWithPluginsItemService(options),
                    }, false, useDataItemService);
                } else {
                    return this._call('/v1/wix-data/collections/truncate', {
                        collectionName,
                        options: this._optionsWithPlugins(options),
                    });
                }
            })
            .then(() => Promise.resolve(null)));
    }
    remove(collectionName, itemId, options) {
        return this._traceWith('platformized-provider-remove', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .itemId(itemId)
            .options(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (useDataItemService) {
                    return this._call('/v2/items/remove', {
                        dataCollectionId: collectionName,
                        dataItemId: itemId,
                        options: this._optionsWithPluginsItemService(options),
                    }, false, useDataItemService).then(this._unwrapDataItem);
                } else {
                    return this._call('/v1/wix-data/collections/remove', {
                        collectionName,
                        itemId,
                        options: this._optionsWithPlugins(options),
                    });
                }
            })
            .catch((err) => {
                if (err && err.code === codes.ItemDoesNotExist) {
                    return Promise.resolve(null);
                }
                return Promise.reject(err);
            }));
    }
    bulkRemove(collectionName, itemIds, options) {
        return this._traceWith('platformized-provider-bulk-remove', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .itemIds(itemIds, collectionName)
            .bulkRemoveOptions(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (itemIds.length === 0) {
                    return {
                        removedItemIds: [],
                        removed: 0,
                        skipped: 0,
                        errors: [],
                    };
                }
                if (useDataItemService) {
                    return this._call('/v2/bulk/items/remove', {
                        dataCollectionId: collectionName,
                        dataItemIds: itemIds,
                        options: this._optionsWithPluginsItemService(options),
                    }, false, true).then(({
                        results
                    }) => {
                        const successes = results.filter((result) => result.itemMetadata.success);
                        // Thats the way wixData API worked with WixDataService. Non-existing items are skipped and not reported as errors.
                        const errors = results.filter((result) => !result.itemMetadata.success &&
                            result.itemMetadata.error.code !== 'WDE0073');
                        const removedItemIds = successes.map((result) => result.itemMetadata.id);
                        return {
                            removedItemIds,
                            removed: removedItemIds.length,
                            skipped: itemIds.length - removedItemIds.length - errors.length,
                            errors: errors.map(parseBulkDataItemsError(itemIds)),
                        };
                    });
                } else {
                    return this._call('/v1/wix-data/collections/bulk-remove', {
                        collectionName,
                        entries: itemIds.map((itemId) => ({
                            itemId
                        })),
                        options: this._optionsWithPlugins(options),
                    }).then((result) => {
                        const {
                            removedItemIds,
                            errors
                        } = result;
                        return {
                            removedItemIds,
                            removed: removedItemIds.length,
                            skipped: itemIds.length - removedItemIds.length - errors.length,
                            errors: errors.map(parseBulkError(itemIds)),
                        };
                    });
                }
            })
            .catch((err) => {
                if (err && err.code === codes.ItemDoesNotExist) {
                    return Promise.resolve(null);
                }
                return Promise.reject(err);
            }));
    }
    get(collectionName, itemId, options) {
        return this._traceWith('platformized-provider-get', {
            collectionName,
            itemId,
        })(() => {
            const fields = options ? .fields || [];
            return apiValidator()
                .collectionName(collectionName)
                .itemId(itemId)
                .options(options)
                .validateAndReject()
                .then(() => this.shouldUseDataItemService)
                .then((useDataItemService) => {
                    if (useDataItemService) {
                        return this._call(`/v2/items/get`, {
                            dataCollectionId: collectionName,
                            dataItemId: itemId,
                            options: this._optionsWithPluginsItemService(options),
                            fields,
                        }, false, useDataItemService).then(this._unwrapDataItem);
                    } else {
                        return this._call('/v1/wix-data/collections/get', {
                            collectionName,
                            itemId,
                            options: this._optionsWithPlugins(options),
                        });
                    }
                })
                .catch((err) => {
                    if (err && err.code === codes.ItemDoesNotExist) {
                        return Promise.resolve(null);
                    }
                    return Promise.reject(err);
                });
        });
    }
    find(collectionName, filter, order, skip, limit, options, include, omitTotalCount, cursor, projectedFields) {
        return this._traceWith('platformized-provider-find', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this._validateOrderBy(collectionName, order))
            .then(() => this._validateFilter(collectionName, filter))
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                const query = this._getDataQuery(filter, order, limit, skip, cursor, projectedFields);
                if (useDataItemService) {
                    return this._call('/v2/items/query', {
                            dataCollectionId: collectionName,
                            query,
                            options: this._optionsWithPluginsItemService(options),
                            includeReferencedItems: include,
                            returnTotalCount: !omitTotalCount,
                        }, true, // preferGet,
                        true).then((response) => {
                        const {
                            dataItems,
                            pagingMetadata
                        } = response;
                        const items = this._unwarpDataItems(dataItems);
                        const isPartialIncludes = !!items.find((item) => {
                            return !!(isArray(include) &&
                                include.find((includedField) => {
                                    const references = item[includedField];
                                    return isArray(references) && references.length >= 50;
                                }));
                        });
                        return {
                            items,
                            partialIncludes: isPartialIncludes,
                            totalCount: pagingMetadata.total,
                            pagingMetadata,
                        };
                    });
                } else {
                    return this._call('/v1/wix-data/collections/query', {
                            collectionName,
                            dataQuery: query,
                            options: this._optionsWithPlugins(options),
                            includeReferencedItems: include,
                            omitTotalCount,
                        }, true // preferGet
                    ).then(({
                        items,
                        partialIncludes,
                        pagingMetadata
                    }) => {
                        return {
                            items,
                            partialIncludes,
                            totalCount: pagingMetadata.total,
                            pagingMetadata,
                        };
                    });
                }
            }));
    }
    runAggregate(collectionName, pipeline, pageSize, options, cursor) {
        return this._traceWith('platformized-provider-aggregate', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                const platformizedPipeline = toPlatformizedAggregate(pipeline);
                if (useDataItemService) {
                    return this._call('/v2/items/aggregate', {
                        dataCollectionId: collectionName,
                        initialFilter: platformizedPipeline.preFilteringStep,
                        aggregation: toDataItemsAggregate(platformizedPipeline.processingStep),
                        finalFilter: platformizedPipeline.postFilteringStep,
                        sort: this._platformizedSort(pipeline),
                        options: this._optionsWithPluginsItemService(options),
                        ...this._getAggregatePaging(pipeline, pageSize, cursor),
                    }, true, true).then((result) => {
                        const {
                            results,
                            pagingMetadata: {
                                cursors,
                                hasNext
                            },
                        } = result;
                        const items = results.map((item) => {
                            // When grouping by one field WixDataService returns value on _id field directly, DataItemService wraps it in an object, i.e.
                            // grouping by surname returns {_id: 'Simpson'} in WixDataService vs {_id: {surname: 'Simpson'}} in DataItemService
                            // When grouping by more fields, values are kept wrapped.
                            if (typeof item._id === 'object' &&
                                Object.keys(item._id).length === 1) {
                                const flattened = item._id[Object.keys(item._id)[0]];
                                item._id = flattened;
                            }
                            return item;
                        });
                        return {
                            items,
                            hasNext,
                            cursors,
                        };
                    });
                } else {
                    return this._call('/v1/wix-data/collections/aggregate', {
                        collectionName,
                        initialFilter: platformizedPipeline.preFilteringStep,
                        aggregation: platformizedPipeline.processingStep,
                        finalFilter: platformizedPipeline.postFilteringStep,
                        sort: this._platformizedSort(pipeline),
                        options: this._optionsWithPlugins(options),
                        ...this._getAggregatePaging(pipeline, pageSize, cursor),
                    }).then((aggregationResult) => {
                        const {
                            items,
                            pagingMetadata: {
                                cursors,
                                hasNext
                            },
                        } = aggregationResult;
                        return {
                            items,
                            hasNext,
                            cursors,
                        };
                    });
                }
            }));
    }
    _optionsWithPluginsItemService(options) {
        const safeOptions = options || {};
        return safeOptions.showDrafts ?
            { ...safeOptions,
                publishPluginOptions: {
                    showDraftItems: true
                }
            } :
            safeOptions;
    }
    _optionsWithPlugins(options) {
        const safeOptions = options || {};
        return safeOptions.showDrafts ?
            { ...safeOptions,
                pluginOptions: {
                    showDrafts: true
                }
            } :
            safeOptions;
    }
    _platformizedSort(pipeline) {
        const sortStage = pipeline.find((stage) => stage.hasOwnProperty('$sort'));
        if (!sortStage) {
            return undefined;
        }
        const platformizedSort = sortStage.$sort.map((sortDefinition) => {
            const [fieldName, order] = Object.entries(sortDefinition)[0];
            return {
                fieldName,
                order: order === 'asc' ? 0 : 1,
            };
        });
        return platformizedSort;
    }
    _getDataQuery(filter, order, limit, skip, cursor, projectedFields) {
        return {
            filter,
            sort: order ? this._mapOrderToSort(order) : undefined,
            ...this._getPaging(limit, skip, cursor),
            fields: projectedFields,
        };
    }
    _getAggregatePaging(pipeline, limit, cursor) {
        const skipStage = pipeline.find((stage) => stage.hasOwnProperty('$skip'));
        const skip = skipStage !== undefined ? skipStage.$skip : undefined;
        return this._getPaging(limit, skip, cursor);
    }
    _getPaging(limit, skip, cursor) {
        if (cursor && skip > 0) {
            throw wixDataError(messages.cursorPagingDoesNotSupportSkip(), codes.ValidationError);
        }
        if (cursor) {
            return {
                cursorPaging: {
                    limit,
                    cursor,
                },
            };
        } else {
            return {
                paging: {
                    offset: skip,
                    limit,
                },
            };
        }
    }
    count(collectionName, filter, options) {
        return this._traceWith('platformized-provider-count', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this._validateFilter(collectionName, filter))
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (useDataItemService) {
                    return this._call('/v2/items/count', {
                        dataCollectionId: collectionName,
                        filter,
                        options: this._optionsWithPluginsItemService(options),
                    }, true, true);
                } else {
                    return this._call('/v1/wix-data/collections/count', {
                        collectionName,
                        filter,
                        options: this._optionsWithPlugins(options),
                    });
                }
            }));
    }
    _sortingFromOrder(order, fieldName) {
        const safeOrder = isArray(order) ? order : [];
        const maybySortForField = safeOrder.find((o) => o.hasOwnProperty(fieldName));
        const sorting = maybySortForField && maybySortForField.hasOwnProperty(fieldName) ?
            maybySortForField[fieldName] :
            undefined;
        return sorting ? sorting.toUpperCase() : sorting;
    }
    distinct(collectionName, filter, order, fieldName, skip, limit, options, cursor, projectedFields, omitTotalCount) {
        return this._traceWith('platformized-provider-distinct', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this._validateOrderBy(collectionName, order))
            .then(() => this._validateFilter(collectionName, filter))
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                const query = this._getDataQuery(filter, order, limit, skip, cursor, projectedFields);
                if (useDataItemService) {
                    return this._call('/v2/items/query-distinct-values', {
                            dataCollectionId: collectionName,
                            fieldName,
                            filter: query.filter,
                            order: this._sortingFromOrder(order, fieldName),
                            options: this._optionsWithPluginsItemService(options),
                            paging: query.paging,
                            cursorPaging: query.cursorPaging,
                            returnTotalCount: !omitTotalCount,
                        }, true, // preferGet,
                        true).then(({
                        distinctValues,
                        pagingMetadata
                    }) => ({
                        items: distinctValues,
                        totalCount: pagingMetadata.total,
                        pagingMetadata,
                    }));
                } else {
                    return this._call('/v1/wix-data/collections/distinct', {
                        collectionName,
                        dataQuery: query,
                        propertyName: fieldName,
                        options: this._optionsWithPlugins(options),
                        omitTotalCount,
                    }).then(({
                        items,
                        pagingMetadata
                    }) => ({
                        items,
                        totalCount: pagingMetadata.total,
                        pagingMetadata,
                    }));
                }
            }));
    }
    bulkInsert(collectionName, items, options) {
        return this._traceWith('platformized-provider-bulk-insert', {
            collectionName,
        })(() => {
            const overrideExisting = (options || {}).overrideExisting;
            return apiValidator()
                .collectionName(collectionName)
                .items(items, collectionName)
                .bulkInsertOptions(options)
                .validateAndReject()
                .then(() => this.shouldUseDataItemService)
                .then((useDataItemService) => {
                    if (items.length === 0) {
                        return {
                            insertedItemIds: [],
                            inserted: 0,
                            errors: [],
                            skipped: 0,
                            updated: 0,
                        };
                    }
                    if (useDataItemService) {
                        const path = overrideExisting ?
                            '/v2/bulk/items/save' :
                            '/v2/bulk/items/insert';
                        return this._call(path, {
                            dataCollectionId: collectionName,
                            dataItems: items.map((item) => ({
                                id: item._id,
                                dataCollectionId: collectionName,
                                data: item,
                            })),
                            options: this._optionsWithPluginsItemService(options),
                        }, false, useDataItemService).then(({
                            results
                        }) => {
                            const successes = results.filter((result) => result.itemMetadata.success);
                            const insertedItemIds = successes.map((result) => result.itemMetadata.id);
                            const inserted = successes.filter((result) => result.action === 'INSERT').length;
                            const updated = successes.filter((result) => result.action === 'UPDATE').length;
                            // in wix-data bulk API when item already exists it is not returned as error, but is counted as skipped.
                            const errors = results.filter((result) => !result.itemMetadata.success &&
                                result.itemMetadata.error.code !== 'WDE0074');
                            return {
                                insertedItemIds,
                                inserted,
                                skipped: overrideExisting ?
                                    0 :
                                    items.length - insertedItemIds.length - errors.length,
                                updated,
                                errors: errors.map(parseBulkDataItemsError(items)),
                            };
                        });
                    } else {
                        return this._call('/v1/wix-data/collections/bulk-insert', {
                            collectionName,
                            items,
                            options: this._optionsWithPlugins(options),
                        }).then((result) => {
                            const {
                                insertedItemIds,
                                errors
                            } = result;
                            return {
                                insertedItemIds,
                                inserted: insertedItemIds.length,
                                skipped: overrideExisting ?
                                    0 :
                                    items.length - insertedItemIds.length - errors.length,
                                updated: overrideExisting ?
                                    items.length - insertedItemIds.length - errors.length :
                                    0,
                                errors: errors.map(parseBulkError(items)),
                            };
                        });
                    }
                });
        });
    }
    bulkSave(collectionName, items, options) {
        return this._traceWith('platformized-provider-bulk-save', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .items(items, collectionName)
            .bulkInsertOptions(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (items.length === 0) {
                    return {
                        insertedItemIds: [],
                        updatedItemIds: [],
                        inserted: 0,
                        updated: 0,
                        skipped: 0,
                        errors: [],
                    };
                }
                if (useDataItemService) {
                    return this._call('/v2/bulk/items/save', {
                        dataCollectionId: collectionName,
                        dataItems: items.map((item) => ({
                            id: item._id,
                            dataCollectionId: collectionName,
                            data: item,
                        })),
                        options: this._optionsWithPluginsItemService(options),
                    }, false, true).then(({
                        results
                    }) => {
                        const successes = results.filter((result) => result.itemMetadata.success);
                        const inserted = successes.filter((result) => result.action === 'INSERT');
                        const updated = successes.filter((result) => result.action === 'UPDATE');
                        const insertedItemIds = inserted.map((item) => item.itemMetadata.id);
                        const updatedItemIds = updated.map((item) => item.itemMetadata.id);
                        const errors = results.filter((result) => !result.itemMetadata.success);
                        return {
                            insertedItemIds,
                            updatedItemIds,
                            inserted: inserted.length,
                            skipped: items.length -
                                insertedItemIds.length -
                                updatedItemIds.length -
                                errors.length,
                            updated: updated.length,
                            errors: errors.map(parseBulkDataItemsError(items)),
                        };
                    });
                } else {
                    return this._call('/v1/wix-data/collections/bulk-save', {
                        collectionName,
                        items,
                        options: this._optionsWithPlugins(options),
                    }).then((result) => {
                        const {
                            insertedItemIds,
                            updatedItemIds,
                            errors
                        } = result;
                        return {
                            insertedItemIds,
                            updatedItemIds,
                            inserted: insertedItemIds.length,
                            skipped: items.length -
                                insertedItemIds.length -
                                updatedItemIds.length -
                                errors.length,
                            updated: updatedItemIds.length,
                            errors: errors.map(parseBulkError(items)),
                        };
                    });
                }
            }));
    }
    bulkUpdate(collectionName, items, options) {
        return this._traceWith('platformized-provider-bulk-update', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .items(items, collectionName)
            .bulkUpdateOptions(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (items.length === 0) {
                    return {
                        updatedItemIds: [],
                        inserted: 0,
                        skipped: 0,
                        updated: 0,
                        errors: [],
                    };
                }
                if (useDataItemService) {
                    return this._call('/v2/bulk/items/update', {
                        dataCollectionId: collectionName,
                        dataItems: items.map((item) => ({
                            id: item._id,
                            dataCollectionId: collectionName,
                            data: item,
                        })),
                        options: this._optionsWithPluginsItemService(options),
                    }, false, true).then(({
                        results
                    }) => {
                        const successes = results.filter((result) => result.itemMetadata.success);
                        const updated = successes.filter((result) => result.action === 'UPDATE');
                        const updatedItemIds = updated.map((item) => item.itemMetadata.id);
                        // Non-existing items are skipped and not reported as errors.
                        const errors = results.filter((result) => !result.itemMetadata.success &&
                            result.itemMetadata.error.code != 'WDE0073');
                        return {
                            updatedItemIds,
                            inserted: 0,
                            skipped: items.length - updatedItemIds.length - errors.length,
                            updated: updated.length,
                            errors: errors.map(parseBulkDataItemsError(items)),
                        };
                    });
                } else {
                    return this._call('/v1/wix-data/collections/bulk-update', {
                        collectionName,
                        items,
                        options: this._optionsWithPlugins(options),
                    }).then((result) => {
                        const {
                            updatedItemIds,
                            errors
                        } = result;
                        return {
                            updatedItemIds,
                            inserted: 0,
                            skipped: items.length - updatedItemIds.length - errors.length,
                            updated: updatedItemIds.length,
                            errors: errors.map(parseBulkError(items)),
                        };
                    });
                }
            }));
    }
    queryReferenced(collectionName, holdingItem, propertyName, options) {
        return this._traceWith('platformized-provider-query-referenced', {
            collectionName,
            order: options.order,
            skip: options.skip,
            limit: options.limit,
            cursorExists: options.cursor ? 'true' : 'false',
        })(() => {
            options = options || {};
            const order = (options.order || 'ASC').toUpperCase();
            const offset = options.skip || 0;
            const limit = options.limit || 50;
            const cursor = options.cursor;
            const omitTotalCount = options.omitTotalCount || false;
            const fields = options ? .fields || [];
            return apiValidator()
                .collectionName(collectionName)
                .options(options)
                .validateAndReject()
                .then(() => this.shouldUseDataItemService)
                .then((useDataItemService) => {
                    if (useDataItemService) {
                        return this._call('/v2/items/query-referenced', {
                            dataCollectionId: collectionName,
                            referringItemId: holdingItem,
                            referringItemFieldName: propertyName,
                            order,
                            ...this._getPaging(limit, offset, cursor),
                            returnTotalCount: !omitTotalCount,
                            options: this._optionsWithPluginsItemService(options),
                            fields,
                        }, true, true).then(({
                            results,
                            pagingMetadata
                        }) => {
                            return {
                                items: results.map((result) => result.dataItem.data),
                                totalCount: pagingMetadata.total,
                                pagingMetadata,
                            };
                        });
                    } else {
                        return this._call('/v1/wix-data/collections/query-referenced', {
                            collectionName,
                            propertyName,
                            referringItemId: holdingItem,
                            order,
                            ...this._getPaging(limit, offset, cursor),
                            omitTotalCount,
                            options: this._optionsWithPlugins(options),
                        }).then(({
                            items,
                            pagingMetadata
                        }) => ({
                            items,
                            totalCount: pagingMetadata.total,
                            pagingMetadata,
                        }));
                    }
                });
        });
    }
    insertReference(collectionName, relationshipName, left, right, options) {
        return this._traceWith('platformized-provider-insert-reference', {
            collectionName,
        })(() => this.insertReferences(collectionName, [{
            relationshipName,
            left,
            right
        }], options));
    }
    insertReferences(collectionName, references, options) {
        return this._traceWith('platformized-provider-insert-references', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (useDataItemService) {
                    const dataItemReferences = references.map(({
                        relationshipName,
                        left,
                        right
                    }) => ({
                        referringItemFieldName: relationshipName,
                        referringItemId: left,
                        referencedItemId: right,
                    }));
                    return this._call('/v2/bulk/items/insert-references', {
                        dataCollectionId: collectionName,
                        dataItemReferences,
                        options: this._optionsWithPluginsItemService(options),
                    }, false, true);
                } else {
                    return this._call('/v1/wix-data/collections/bulk-insert-references', {
                        collectionName,
                        references: references.map(({
                            relationshipName,
                            left,
                            right
                        }) => ({
                            propertyName: relationshipName,
                            referringItemId: left,
                            referencedItemId: right,
                        })),
                        options: this._optionsWithPlugins(options),
                    });
                }
            }));
    }
    replaceReferences(collectionName, query, newReferences, options) {
        return this._traceWith('platformized-provider-replace-references', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (useDataItemService) {
                    return this._call('/v2/items/replace-references', {
                        dataCollectionId: collectionName,
                        referringItemFieldName: query.relationshipName,
                        referringItemId: query.left,
                        newReferencedItemIds: newReferences.map(({
                            right
                        }) => right),
                        options: this._optionsWithPluginsItemService(options),
                    }, false, true);
                } else {
                    return this._call('/v1/wix-data/collections/bulk-replace-references', {
                        collectionName,
                        propertyName: query.relationshipName,
                        referringItemId: query.left,
                        newReferencedItemIds: newReferences.map(({
                            right
                        }) => right),
                        options: this._optionsWithPlugins(options),
                    });
                }
            }));
    }
    removeReference(collectionName, relationshipName, left, right, options) {
        return this._traceWith('platformized-provider-remove-reference', {
            collectionName,
        })(() => this.removeReferences(collectionName, [{
            relationshipName,
            left,
            right
        }], options));
    }
    removeReferences(collectionName, references, options) {
        return this._traceWith('platformized-provider-remove-references', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (useDataItemService) {
                    return this._call('/v2/bulk/items/remove-references', {
                        dataCollectionId: collectionName,
                        dataItemReferences: references.map(({
                            relationshipName,
                            left,
                            right
                        }) => ({
                            referringItemFieldName: relationshipName,
                            referringItemId: left,
                            referencedItemId: right,
                        })),
                        options: this._optionsWithPluginsItemService(options),
                    }, false, true);
                } else {
                    return this._call('/v1/wix-data/collections/bulk-remove-references', {
                        collectionName,
                        references: references.map(({
                            relationshipName,
                            left,
                            right
                        }) => ({
                            propertyName: relationshipName,
                            referringItemId: left,
                            referencedItemId: right,
                        })),
                        options: this._optionsWithPlugins(options),
                    });
                }
            }));
    }
    isReferenced(collectionName, propertyName, left, right, options) {
        return this._traceWith('platformized-provider-is-referenced', {
            collectionName,
        })(() => apiValidator()
            .collectionName(collectionName)
            .options(options)
            .validateAndReject()
            .then(() => this.shouldUseDataItemService)
            .then((useDataItemService) => {
                if (useDataItemService) {
                    return this._call('/v2/items/is-referenced', {
                        dataCollectionId: collectionName,
                        referringItemFieldName: propertyName,
                        referringItemId: left,
                        referencedItemId: right,
                        options: this._optionsWithPluginsItemService(options),
                    }, false, true);
                } else {
                    return this._call('/v1/wix-data/collections/is-referenced', {
                        collectionName,
                        propertyName,
                        referringItemId: left,
                        referencedItemId: right,
                        options: this._optionsWithPlugins(options),
                    });
                }
            })
            .then(({
                isReferenced
            }) => isReferenced));
    }
    _mapOrderToSort(order) {
        return order.flatMap((o) => Object.entries(o).map(([key, value]) => ({
            fieldName: key,
            order: value.toUpperCase(),
        })));
    }
    _validateOrderBy(collectionName, order) {
        const isNotArray = (elem) => !isArray(elem);
        const isNotObject = (elem) => !isObject(elem);
        const isInvalidSort = (elem) => {
            const values = Object.values(elem);
            const isValid = values.length === 1 && (values[0] === 'asc' || values[0] === 'desc');
            return !isValid;
        };
        const nonArrayMessage = (elem) => messages.orderByValidations.sortModelType(elem);
        const nonObjectMessage = (elem) => messages.orderByValidations.sortModelItemType(elem);
        const invalidSortMessage = (elem) => messages.orderByValidations.sortModelItem(elem);
        if ([null, undefined].includes(order)) {
            return Promise.resolve();
        }
        if (isNotArray(order)) {
            return Promise.reject(this._validationError(collectionName, [nonArrayMessage(order)]));
        }
        const errors = order.flatMap((elem) => {
            if (isNotObject(elem)) {
                return nonObjectMessage(elem);
            }
            if (isInvalidSort(elem)) {
                return invalidSortMessage(elem);
            }
            return [];
        });
        return errors.length ?
            Promise.reject(this._validationError(collectionName, errors)) :
            Promise.resolve();
    }
    _validateFilter(collectionName, filter) {
        const objectType = messages.filterTreeValidations.objectType;
        const arrayType = messages.filterTreeValidations.arrayType;
        const arrayLength = messages.filterTreeValidations.arrayLength;
        const comparisonOperatorType = messages.filterTreeValidations.comparisonOperatorType;
        const stringOperatorType = messages.filterTreeValidations.stringOperatorType;
        const setOperatorItems = messages.filterTreeValidations.setOperatorItems;
        const inOperatorItems = messages.filterTreeValidations.inOperatorItems;
        const matchesOperatorRequiredProperty = messages.filterTreeValidations.matchesOperatorRequiredProperty;
        const matchesOperatorIgnoreCase = messages.filterTreeValidations.matchesOperatorIgnoreCase;
        const matchesOperatorSpecItems = messages.filterTreeValidations.matchesOperatorSpecItems;
        const regexNotAllowed = messages.filterTreeValidations.regexNotAllowed;
        const objectTypeErrors = (operatorName, value) => {
            if (value === undefined) {
                return [];
            }
            if (isObject(value)) {
                return [];
            }
            return [objectType(operatorName, value)];
        };
        const arrayContainsNonObjectsErrors = (operatorName, value) => {
            if (!isArray(value)) {
                return [];
            }
            return value.flatMap((v) => objectTypeErrors(operatorName, v));
        };
        const nonArrayErrors = (operatorName, value) => {
            if (value === undefined) {
                return [];
            }
            if (isArray(value)) {
                return [];
            }
            return [arrayType(operatorName, value)];
        };
        const comparisonInvalidErrors = (operatorName, value) => {
            if (value === undefined) {
                return [];
            }
            if (isString(value) || isNumber(value) || isDate(value)) {
                return [];
            }
            return [comparisonOperatorType(operatorName, value)];
        };
        const nonStringOperatorErrors = (operatorName, value) => {
            if (value === undefined) {
                return [];
            }
            if (isString(value)) {
                return [];
            }
            return [stringOperatorType(operatorName, value)];
        };
        const nonSetOperatorErrors = (operatorName, value) => {
            const isSetOperator = (elem) => isDate(elem) || isString(elem) || isNumber(elem);
            if (!isArray(value)) {
                return [];
            }
            if (value.every(isSetOperator)) {
                return [];
            }
            return [setOperatorItems(operatorName, value)];
        };
        const arrayLengthErrors = (operatorName, value, expectedLength) => {
            if (!isArray(value)) {
                return [];
            }
            if (value.length === expectedLength) {
                return [];
            }
            return [arrayLength(operatorName, expectedLength, value)];
        };
        const inOperatorItemErrors = (value) => {
            if (!isArray(value)) {
                return [];
            }
            if (value.length !== 2) {
                return [];
            }
            if (isString(value[0]) && isNumber(value[1])) {
                return [];
            }
            return [inOperatorItems(value)];
        };
        const matchesValidationErrors = (value) => {
            const isValidSpec = (spec) => {
                if (!isObject(spec)) {
                    return false;
                }
                if (spec.type === 'anyOf' && spec.value === ' \t\n-') {
                    return true;
                }
                if (spec.type === 'literal' && isString(spec.value)) {
                    return true;
                }
                return false;
            };
            if (!isObject(value)) {
                return [];
            }
            if (value.ignoreCase === undefined) {
                return [matchesOperatorRequiredProperty('ignoreCase', value)];
            }
            if (value.ignoreCase !== true) {
                return [matchesOperatorIgnoreCase(value.ignoreCase)];
            }
            if (value.spec === undefined) {
                return [matchesOperatorRequiredProperty('spec', value)];
            }
            if (!isArray(value.spec)) {
                return [arrayType('$matches.spec', value.spec)];
            }
            const invalidSpec = value.spec.find((spec) => !isValidSpec(spec));
            if (invalidSpec !== undefined) {
                return [matchesOperatorSpecItems(invalidSpec)];
            }
            return [];
        };
        const regexNotAllowedErrors = (value) => {
            if (value === undefined) {
                return [];
            }
            return [regexNotAllowed()];
        };
        const getErrors = (filterRecords) => {
            if (!isObject(filterRecords)) {
                return [];
            }
            const {
                $and,
                $or,
                $not,
                $gt,
                $gte,
                $lt,
                $lte,
                $startsWith,
                $endsWith,
                $contains,
                $hasSome,
                $hasAll,
                $in,
                $matches,
                $regex,
                ...restOfFilter
            } = filterRecords;
            let errors = []
                .concat(nonArrayErrors('$and', $and))
                .concat(arrayContainsNonObjectsErrors('Filter Model', $and))
                .concat(nonArrayErrors('$or', $or))
                .concat(arrayContainsNonObjectsErrors('Filter Model', $or))
                .concat(nonArrayErrors('$not', $not))
                .concat(arrayContainsNonObjectsErrors('Filter Model', $not))
                .concat(nonArrayErrors('$hasSome', $hasSome))
                .concat(nonArrayErrors('$hasAll', $hasAll))
                .concat(nonArrayErrors('$in', $in))
                .concat(nonSetOperatorErrors('$hasSome', $hasSome))
                .concat(nonSetOperatorErrors('$hasAll', $hasAll))
                .concat(comparisonInvalidErrors('$gt', $gt))
                .concat(comparisonInvalidErrors('$gte', $gte))
                .concat(comparisonInvalidErrors('$lt', $lt))
                .concat(comparisonInvalidErrors('$lte', $lte))
                .concat(nonStringOperatorErrors('$startsWith', $startsWith))
                .concat(nonStringOperatorErrors('$endsWith', $endsWith))
                .concat(nonStringOperatorErrors('$contains', $contains))
                .concat(arrayLengthErrors('$not', $not, 1))
                .concat(arrayLengthErrors('$in', $in, 2))
                .concat(inOperatorItemErrors($in))
                .concat(objectTypeErrors('$matches', $matches))
                .concat(matchesValidationErrors($matches))
                .concat(regexNotAllowedErrors($regex));
            if (errors.length) {
                return errors;
            }
            errors = []
                .concat($and ? $and.flatMap(getErrors) : [])
                .concat($or ? $or.flatMap(getErrors) : [])
                .concat($not ? $not.flatMap(getErrors) : []);
            if (errors.length) {
                return errors;
            }
            return Object.values(restOfFilter).flatMap(getErrors);
        };
        if ([null, undefined].includes(filter)) {
            return Promise.resolve();
        } else if (!isObject(filter)) {
            return Promise.reject(this._validationError(collectionName, [
                objectType('Filter Model', filter),
            ]));
        }
        const errors = getErrors(filter);
        return errors.length ?
            Promise.reject(this._validationError(collectionName, errors)) :
            Promise.resolve();
    }
    _validationError(collectionName, invalidArguments) {
        return validationError(messages.queryValidations.queryInvalid(collectionName, invalidArguments));
    }
    _getAuthHeader() {
        return Promise.resolve(isProvider(this.authHeader) ? this.authHeader.get() : this.authHeader);
    }
    _call(path, body, preferGet = false, useItemService = false) {
        return Promise.all([this._getGridAppId(), this._getAuthHeader()]).then(([gridAppId, authHeader]) => {
            return this.traceWith('wix-data-api-call', {
                url: `${this.cloudDataUrl}${path}`,
                options: JSON.stringify(body.options),
            })(() => {
                const data = useItemService ?
                    serializeDates(Object.assign(body, {
                        environment: this.segment.toUpperCase(),
                        appId: gridAppId,
                    })) :
                    serializeDates(Object.assign(body, {
                        segment: this.segment.toUpperCase(),
                        appId: gridAppId,
                    }));
                const headers = authHeader ? {
                    authorization: authHeader
                } : {};
                if (preferGet && this.allowGetRequests) {
                    // https://github.com/wix-private/server-infra/tree/master/framework/grpc/rest#complex-requests-messages-with-get-mappings
                    const url = `${this.cloudDataUrl}${path}?.r=${base64url(data)}`;
                    // Min limit for URLs is 2,083 but not sure if HTTP client or browser will add i.e. http://
                    if (url.length <= 2048) {
                        return this.httpClientProvider(body.options)
                            .get(url, {
                                headers
                            })
                            .catch(handleJsonErrorResponse(this.traceWith))
                            .then(handleJsonResponse(this.traceWith));
                    }
                }
                return this.httpClientProvider(body.options)
                    .post(`${this.cloudDataUrl}${path}`, data, {
                        headers
                    })
                    .catch(handleJsonErrorResponse(this.traceWith))
                    .then(handleJsonResponse(this.traceWith));
            });
        });
    }
    _getGridAppId() {
        return Promise.resolve(isProvider(this.gridAppId) ? this.gridAppId.get() : this.gridAppId);
    }
    _traceWith(methodName, options) {
        return (fn) => this._getGridAppId().then((gridAppId) => {
            return this.traceWith(methodName, {
                gridAppId,
                segment: this.segment,
                ...options,
            })(fn);
        });
    }
}
//# sourceMappingURL=platformized-data-provider.js.map