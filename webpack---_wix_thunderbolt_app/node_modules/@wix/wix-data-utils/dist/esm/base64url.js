/* eslint-disable no-control-regex */
export default function base64url(data) {
    if (typeof data !== 'string') {
        data = JSON.stringify(data);
    }
    return btoa(toBinary(data))
        .replace(/[+/]/g, (c) => subst[c])
        .replace(/={1,3}$/, '');
}
const subst = {
    '+': '-',
    '/': '_',
};

function toBinary(s) {
    if (typeof TextEncoder === 'function') {
        const bytes = new TextEncoder().encode(s);
        return Array.from(bytes, (byte) => String.fromCodePoint(byte)).join('');
    }
    return s.replace(nonAsciiRegex, toBytes);
}
const nonAsciiRegex = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
const fromCode = (code) => String.fromCharCode(code);

function toBytes(c) {
    if (c.length < 2) {
        const cc = c.charCodeAt(0);
        return cc < 0x80 ?
            c :
            cc < 0x800 ?
            fromCode(0xc0 | (cc >>> 6)) + fromCode(0x80 | (cc & 0x3f)) :
            fromCode(0xe0 | ((cc >>> 12) & 0x0f)) +
            fromCode(0x80 | ((cc >>> 6) & 0x3f)) +
            fromCode(0x80 | (cc & 0x3f));
    }
    const cc = 0x10000 + (c.charCodeAt(0) - 0xd800) * 0x400 + (c.charCodeAt(1) - 0xdc00);
    return (fromCode(0xf0 | ((cc >>> 18) & 0x07)) +
        fromCode(0x80 | ((cc >>> 12) & 0x3f)) +
        fromCode(0x80 | ((cc >>> 6) & 0x3f)) +
        fromCode(0x80 | (cc & 0x3f)));
}
//# sourceMappingURL=base64url.js.map